/// A type for which abstract value equality forms a [partial equivalence relation](https://en.wikipedia.org/wiki/Partial_equivalence_relation).
/// For example, floating point numbers implement `Partially_Equatable` because the special value
/// "not a number" (NaN) cannot be compared to itself. The result of `NaN == NaN` is `none`.
///
/// # Remarks
///
/// Types that have multiple reasonably definitions of equality without one that is clearly what
/// most would consider equal should not implement this trait. Instead, multiple
/// `Partial_Equivalence` implementations should be provided and developers can select which to
/// apply in any given situation using a `with` block. For example, Unicode strings can be compared
/// either by their Unicode scalar sequence or by converting to normal form and comparing or
/// relative to some culture. As such, unicode strings should not implement `==`. On the other hand,
/// ASCII strings can be compared case sensitive or case insensitive, but the case sensitive
/// comparison is the one that would be clearly considered equal. So ASCII strings should provide
/// `==` that compares strings in a case sensitive manner.
///
/// This trait provides a way compare a type (or family of types) for abstract value equality. This
/// means that two objects/values are considered equal when their abstract values are substitutable
/// for each other. Typically, this means that they are behaviorally equal. That is, in almost all
/// ways the behavior of the two values is indistinguishable. Of course, there are some aspects of
/// an object that are not part of its abstract value but may still be behaviorally observable. For
/// objects, the first such aspect is object identity. If two references refer to the same object
/// (e.g. `a === b`) then they must necessarily be equal (i.e. `a == b`). However, the inverse is
/// not the case. This is because object identity is never considered to be part of the abstract
/// value of an object/value. Another example is types which have multiple internal representations
/// for a value. These internal representations may be distinguishable by certain operations or by
/// inspecting the bytes of the value, but they represent the same abstract value and should be
/// equal. A final example is that for floating point types `-0 == 0`. Here their are some
/// behavioral differences since `1/0 == Inf` while `1/-0 == -Inf`. Nevertheless, the sign of zero
/// is not considered to be part of the abstract value.
///
/// Generally, equality should reflect behavioral equality except for object identity and multiple
/// internal representations of a value. If equality is being defined in a way that treats values
/// that are behaviorally distinct in other ways as equal, one should strongly consider not
/// implementing `Partially_Equatable` and instead providing a `Partial_Equivalence`.
///
/// Because two values should be behaviorally equal to be considered equal, the `==` operation is
/// defined only over `const` values. This is because if two distinct mutable objects were
/// considered equal and one was mutated, then they would not longer be behaviorally equal. For
/// comparison on mutable values, use `Partial_Equivalence`.
public trait Partially_Equatable[const Domain]
// TODO where Self <: Domain
// TODO where Domain <: Partially_Equatable[Domain]
{
    /// The domain of types that can be compared for equality.
    ///
    /// # Remarks
    ///
    /// The `Domain` type is invariant even though it is only used for input because it does not
    /// make sense to expand the domain of equality in subclasses. If it were done, that would imply
    /// that the base class ought to also be comparable within that domain.
    // TODO replace the generic parameter `Domain` with an associated type:
    // published in type Domain;
    // TODO where Self <: Domain
    // TODO where Domain <: Partially_Equatable[.Domain = Domain]

    /// Determine whether the two values are equal. If they cannot be compared, returns `none`.
    ///
    /// # Remarks
    ///
    /// This method must define a relationship, here represented with the '==' symbol, that has
    /// the following properties:
    ///
    /// * symmetry: a == b if and only if b == a (likewise a == b is `none` if and only if b == a is `none`)
    /// * transitivity: if a == b and b == c then a == c
    /// * substitutability: if a == b then it should be possible to substitute b for a in all
    ///   expressions that depend only on the abstract value of a. Put another way, a and b should
    ///   be behaviorally equal except for those aspects and operations that distinguish more than
    ///   just the abstract value.
    ///
    /// Implementations that do not have these properties can lead to unexpected behavior.
    ///
    /// Note that partial equality is not reflective. That is, there may be values such that a R a
    /// returns `none`.
    ///
    // TODO more discussion of implementing equals and the need to check other is Type
    /// Implementing `==` properly on types that are not sealed requires extra caution to ensure
    /// that the implementation if symmetric even as new subtypes are added to the hierarchy. The
    /// `can_equal` method is provided to support this. To ensure symmetry define equality as
    /// `other.can_equal(self) and ...` followed by all the conditions for equality.
    // TODO replace with operator ==
    public fn equals(const self, other: Domain) -> bool?;
    // TODO is it possible to enforce the properties with `ensures`?
    // ensures return implies other == self
    // ensures let a:Domain, b:Domain, c:Domain; a==b and b==c implies a==c;

    /// Whether `other` can be compared to `self`.
    ///
    /// # Returns
    ///
    /// * `true` if they can be compared (i.e. `==` should compare their abstract values)
    /// * `false` if they are not equal to each other (i.e. `==` should return `false`)
    /// * `none` if they cannot be compared to each other (i.e. `==` should return `none`)
    ///
    /// # Remarks
    ///
    /// The default implementation of `can_equal` is `other is Self` and will be correct in most
    /// cases. However, it will need to be overridden in cases where a different type wishes to
    /// compare equal. For example, if a type is a proxy it may wish to compare equal to the type
    /// it is a proxy for.
    // TODO add can_equal
    published protected fn can_equal(const self, other: Domain) -> bool?
        => other is Self;

    /// Determine whether the two values are not equal. If they cannot be compared, returns `none`.
    ///
    /// # Remarks
    ///
    /// The default implementation should be sufficient in almost all cases. In rare cases, it can
    /// be overridden to provide improved performance.
    ///
    /// When overriding, implementations must ensure that `(a =/= b) == not (a == b)`.
    // TODO add not equal operator
    // public operator _=/=_(const self, other: Domain) -> bool?
    //     => not (self == other);
}
