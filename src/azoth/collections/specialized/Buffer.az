/// A growable buffer of data.
///
/// # Remarks
/// Used internally by collections to ensure efficent memory management. Can be used by performance
/// critical code to avoid extra layers of indirection.
published move /*struct*/ class Buffer[T]
    // invariant .get_count() <= get_capacity()
{
    // const DefaultCapacity: size = 16;

    // TODO use optional type to avoid allocating empty `Raw_Bounded_List[T]`
    var items: mut Raw_Hybrid_Bounded_List[void, T];

    published new(mut self)
        // #prove ensures .get_count() == 0 and .get_capacity() == DefaultCapacity
    {
        let DefaultCapacity: size = 16; // TODO make this a constant
        .items = new Raw_Hybrid_Bounded_List[void, T](DefaultCapacity);
    }

    // TOOD name: with_capacity
    published new(mut self, capacity: size)
        // #prove ensures .get_count() == 0 and .get_capacity() == capacity
    {
        .items = new Raw_Hybrid_Bounded_List[void, T](capacity);
    }

    published fn get_capacity(self) -> size
        => .items.get_capacity();

    published fn get_count(self) -> size
        => .items.get_count();

    published fn at(self, index: size) -> T
        // requires index < .get_count()
    {
        let count = .items.get_count();
        if index >= count => ABORT("at(): index out of bounds");
        return .items.at(index);
    }

    published fn set_at(mut self, index: size, value: T)
        // requires index < .get_count()
    {
        let count = .items.get_count();
        if index >= count => ABORT("set_at(): index out of bounds");
        .items.set_at(index, value);
    }

    published fn add(mut self, value: T)
        // #prove ensures old.get_count() == .get_count() + 1
    {
        .ensure_capacity(.items.get_count() + 1);
        .items.add(value);
    }

    published fn remove_at(mut self, index: size) -> T
        // requires index < .get_count()
        // #prove ensures old.get_count() == .get_count() - 1
    {
        let count = .items.get_count();
        if index >= count => ABORT("remove_at(): index out of bounds");
        let item = .items.at(index);
        foreach i in index..<(count - 1)
            { .items.set_at(i, .items.at(i + 1)); }
        .items.shrink(count - 1);
        return item;
    }

    published fn clear(mut self)
        // #prove ensures .get_count() == 0
        => .items.shrink(0);

    published fn ensure_capacity(mut self, min_capacity: size)
        // #prove ensures .get_capacity() >= min_capacity
    {
        var capacity = .items.get_capacity();
        if min_capacity <= capacity => return;
        let DefaultCapacity: size = 16; // TODO make this a constant
        if capacity < DefaultCapacity { capacity = DefaultCapacity; }
        while capacity < min_capacity { capacity *= 2; }
        .resize_to(capacity);
    }

    fn resize_to(mut self, new_capacity: size)
        // requires new_capacity >= .get_count()
        // #prove ensures .get_capacity() == new_capacity
    {
        let new_items: mut = new Raw_Hybrid_Bounded_List[void, T](new_capacity);
        let count = .get_count();
        // TODO create a more efficent copy mechanism
        foreach i in 0..<count
            { new_items.add(.items.at(i)); }
        .items = new_items;
    }

    /// Trim the capacity of this `Buffer[T]` down to `count`
    published fn trim_to_count(mut self)
        // #prove ensures .get_capacity() == .get_count()
    {
        let count = .get_count();
        if .get_capacity() == count => return;
        .resize_to(count);
    }

    /// Trim the capacity of this `Buffer[T]` down to what it would be if `.get_count()` items
    /// were added to a new `Buffer[T]`.
    published fn trim_excess_capacity(mut self)
    {
        let DefaultCapacity: size = 16; // TODO make this a constant
        let count = .get_count();
        var capacity = DefaultCapacity;
        while capacity < count { capacity *= 2; }
        if capacity < .get_capacity() { .resize_to(capacity); }
    }
}
