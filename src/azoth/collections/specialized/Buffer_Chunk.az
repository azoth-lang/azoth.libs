/// A chunk of a buffer stored as a linked list of chunks. Each chunk is a bounded list and has a
/// reference to the next chunk.
published class Buffer_Chunk[T] <: Collection[T]
    // invariant .get_count() <= get_capacity()
{
    // const DefaultCapacity: size = 16;

    // TODO use private inheritance to avoid extra indirection
    var items: mut Raw_Hybrid_Bounded_List[mut Buffer_Chunk[T]?, T];

    published new(mut self)
        // #prove ensures .get_count() == 0 and .get_capacity() == DefaultCapacity
    {
        let DefaultCapacity: size = 16; // TODO make this a constant
        .items = new Raw_Hybrid_Bounded_List[mut Buffer_Chunk[T]?, T](none, DefaultCapacity);
    }

    published new(mut self, capacity: size)
        // #prove ensures .get_count() == 0 and .get_capacity() == capacity
    {
        .items = new Raw_Hybrid_Bounded_List[mut Buffer_Chunk[T]?, T](none, capacity);
    }

    published new(mut self, capacity: size, next_chunk: mut Buffer_Chunk[T])
        // #prove ensures .get_count() == 0 and .get_capacity() == capacity
    {
        .items = new Raw_Hybrid_Bounded_List[mut Buffer_Chunk[T]?, T](next_chunk, capacity);
    }

    published fn get_next_chunk(mut self) -> mut Buffer_Chunk[T]?
        => .items.get_fixed();

    published fn get_capacity(self) -> size
        => .items.get_capacity();

    published fn is_full(self) -> bool
        => .items.get_count() == .items.get_capacity();

    published fn get_count(self) -> size
        => .items.get_count();

    published fn at(self, index: size) -> T
        // requires index < .get_count()
    {
        let count = .items.get_count();
        if index >= count => ABORT("at(): index out of bounds");
        return .items.at(index);
    }

    published fn set_at(mut self, index: size, value: T)
        // requires index < .get_count()
    {
        let count = .items.get_count();
        if index >= count => ABORT("set_at(): index out of bounds");
        .items.set_at(index, value);
    }

    published fn try_add(mut self, value: T) -> bool
        // #prove ensures old.get_count() == .get_count() + 1
    {
        if .items.get_count() == .items.get_capacity() => return false;
        .items.add(value);
        return true;
    }

    published fn remove_at(mut self, index: size) -> T
        // requires index < .get_count()
        // #prove ensures old.get_count() == .get_count() - 1
    {
        let count = .items.get_count();
        if index >= count => ABORT("remove_at(): index out of bounds");
        let item = .items.at(index);
        foreach i in index..<(count - 1)
            { .items.set_at(i, .items.at(i + 1)); }
        .items.shrink(count - 1);
        return item;
    }

    published fn clear(mut self)
        // #prove ensures .get_count() == 0
        => .items.shrink(0);
}
