
/// A range represents a range of discrete values that are naturally ordered(e.g `int`).
/// # Remarks
/// To empty ranges are equal even if
published /*sealed*/ const class /*struct*/ range[T] <: Ordered[range[T]], Reversible_Iterable[T]
    // where T <: Steppable
{
    /// The inclusive start of the range or `none` if the start is unbounded.
    published let start: T?;

    /// The inclusive end of the ranger or `none` if the end is unbounded
    published let end: T?;

    // published fn is_empty(const self) -> bool
    //     => .end < .start;
}

// The range classes are temporary classes used to handle range expressions.
// Eventually, there will be a single generic range struct. Currently, ranges
// not including their endpoints are represented by moving the endpoint. Open
// ranges are represented use min and max values. The current foreach loop
// uses `count` and `at()` to iterate over things, so the range classes have
// those.

// TODO range is for discrete values (e.g. ints) interval is for continous values.

/*published class Size_range
{
    published let start: size;
    published let end: size;
    // TODO make this a computed property
    published let count: size;

    published new(.start, .end)
        // requires start <= end
    {
        self.count = self.end - self.start + 1;
    }

    published fn at(self, index: size) -> size
        // requires index < .count
    {
        return .start + index;
    }
}*/
